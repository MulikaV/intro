import _extends from "@babel/runtime/helpers/extends";
import _regeneratorRuntime from "@babel/runtime/regenerator";

var _marked =
/*#__PURE__*/
_regeneratorRuntime.mark(cancelSendRequestOnAction),
    _marked2 =
/*#__PURE__*/
_regeneratorRuntime.mark(watchRequests);

import { call, fork, join, take, race, cancel } from 'redux-saga/effects';
import { isRequestAction, isRequestActionQuery } from '../actions';
import sendRequest from './send-request';
/* eslint-disable */

var delay = require('redux-saga').delay || require('@redux-saga/delay-p')["default"];
/* eslint-enable */


var watchRequestsDefaultConfig = {
  takeLatest: isRequestActionQuery,
  abortOn: null,
  getLastActionKey: function getLastActionKey(action) {
    return action.type;
  }
};
export function cancelSendRequestOnAction(abortOn, task) {
  var _ref, abortingAction;

  return _regeneratorRuntime.wrap(function cancelSendRequestOnAction$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _context.next = 2;
          return race({
            abortingAction: take(abortOn),
            taskFinished: join(task),
            timeout: call(delay, 10000) // taskFinished doesnt work for aborted tasks

          });

        case 2:
          _ref = _context.sent;
          abortingAction = _ref.abortingAction;

          if (!abortingAction) {
            _context.next = 7;
            break;
          }

          _context.next = 7;
          return cancel(task);

        case 7:
        case "end":
          return _context.stop();
      }
    }
  }, _marked);
}

var isWatchable = function isWatchable(a) {
  return isRequestAction(a) && (!a.meta || a.meta.runByWatcher !== false);
};

export default function watchRequests(commonConfig) {
  var lastTasks, config, action, lastActionKey, takeLatest, activeTask, newTask, abortOn;
  return _regeneratorRuntime.wrap(function watchRequests$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          if (commonConfig === void 0) {
            commonConfig = {};
          }

          lastTasks = {};
          config = _extends({}, watchRequestsDefaultConfig, {}, commonConfig);

        case 3:
          if (!true) {
            _context2.next = 24;
            break;
          }

          _context2.next = 6;
          return take(isWatchable);

        case 6:
          action = _context2.sent;
          lastActionKey = config.getLastActionKey(action);
          takeLatest = action.meta && action.meta.takeLatest !== undefined ? action.meta.takeLatest : typeof config.takeLatest === 'function' ? config.takeLatest(action) : config.takeLatest;

          if (!takeLatest) {
            _context2.next = 14;
            break;
          }

          activeTask = lastTasks[lastActionKey];

          if (!activeTask) {
            _context2.next = 14;
            break;
          }

          _context2.next = 14;
          return cancel(activeTask);

        case 14:
          _context2.next = 16;
          return fork(sendRequest, action);

        case 16:
          newTask = _context2.sent;

          if (takeLatest) {
            lastTasks[lastActionKey] = newTask;
          }

          abortOn = action.meta && action.meta.abortOn ? action.meta.abortOn : config.abortOn;

          if (!abortOn) {
            _context2.next = 22;
            break;
          }

          _context2.next = 22;
          return fork(cancelSendRequestOnAction, abortOn, newTask);

        case 22:
          _context2.next = 3;
          break;

        case 24:
        case "end":
          return _context2.stop();
      }
    }
  }, _marked2);
}